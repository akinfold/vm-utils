#!/bin/bash

#
# Check that script runing under root priveleges
#
if [[ $(id -u) -ne 0 ]]; then 
    echo "Please run as root"
    exit 1
fi

# Exit immediately if a pipeline returns a non-zero status.
# https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#The-Set-Builtin
set -e 

. "./env.sh"

#
# Add user to run docker containers and other staff.
#
if id "$PROJECT_USER_NAME" >/dev/null 2>&1; then
    echo "Project user "$PROJECT_USER_NAME" found."
else
    echo "Project user "$PROJECT_USER_NAME" not found. Create one."
    useradd -m -d "/home/$PROJECT_USER_NAME" -s /bin/bash $PROJECT_USER_NAME
fi

#
# Create initial folder structure if doesnt exists.
# All variables are set in "./env.sh" file.
#
mkdir -p "$ROOT_PATH"
chown $PROJECT_USER_NAME:$PROJECT_USER_NAME "$ROOT_PATH"

mkdir -p "$LOGS_PATH"
chown $PROJECT_USER_NAME:$PROJECT_USER_NAME "$LOGS_PATH"

mkdir -p "$SECRETS_PATH"
chown root:root "$SECRETS_PATH"
chmod 600 "$SECRETS_PATH"

#
# Check or create stages status file.
# 
STATUS_FILE="$ROOT_PATH/.vm-utils-initial-setup-stages"
STATUS_DONE="done"
STATUS_FAILED="failed"

function commit_stage_status {
    if [[ $# -eq 2 ]]; then
        if [[ ! -f $STATUS_FILE ]]; then
            echo "Status file not found in $STATUS_FILE. Create new one."
            touch $STATUS_FILE
            echo "# This file auto generated by init script https://github.com/akinfold/vm-utils/blob/main/initial-setup.sh" > $STATUS_FILE
        fi
        sed -i "/^$1=.*/d" $STATUS_FILE
        if [[ -n $2 ]]; then
            echo "$1=$2  # $(date +'%Y-%m-%dT%H:%M:%S%z')" >> $STATUS_FILE
        fi
    else
        echo "Usage: commit_stage_status STAGE_NAME STATUS"
        exit 1
    fi
}

function commit_stage_done {
    if [[ $# -eq 1 ]]; then
        commit_stage_status $1 $STATUS_DONE
    else
        echo "Usage: commit_stage_done STAGE_NAME"
        exit 1
    fi
}

function commit_stage_failed {
    if [[ $# -eq 1 ]]; then
        commit_stage_status $1 $STATUS_FAILED
    else
        echo "Usage: commit_stage_failed STAGE_NAME"
        exit 1
    fi
}

function reset_stage_status {
    if [[ $# -eq 1 ]]; then
        commit_stage_status $1 ""
    else
        echo "Usage: reset_stage_status STAGE_NAME"
        exit 1
    fi
}

function read_stage_status {
    if [ $# -eq 1 ]; then
        echo "$( cat $STATUS_FILE | grep $1 | tail -n1 | cut -d "=" -f 2 | sed -e 's:#.*$::g' -e 's/^"//' -e 's/"$//' -e 's/^\s*//' -e 's/\s*$//' )"
    else
        echo "Usage: read_stage_status STAGE_NAME"
        exit 1
    fi
}

function check_stage_done {
    if [[ $# -eq 1 ]]; then
        [[ $(read_stage_status $1) == $STATUS_DONE ]]
    else
        echo "Usage: check_stage_done STAGE_NAME"
        exit 1
    fi
}

STAGE_NAME='create_stages_status_file'
commit_stage_done $STAGE_NAME


# 
# Setup hostname
# https://linuxconfig.org/setting-the-hostname-on-ubuntu-24-04
STAGE_NAME='setup_hostname'
NEED_SETUP_HOSTNAME=""
NEW_HOSTNAME=""
OLD_HOSTNAME=$( hostname )
HOSTS_FILE="/etc/hosts"
if ! check_stage_done $STAGE_NAME; then
    OLD_HOSTNAME=
    echo "Current hostname: $OLD_HOSTNAME"
    while [[ $NEED_SETUP_HOSTNAME != "y" ]] && [[ $NEED_SETUP_HOSTNAME != "n" ]]; do
        echo -n "Setup new hostname? [y/n] "
        read NEED_SETUP_HOSTNAME
        if [[ $NEED_SETUP_HOSTNAME == "y" ]]; then
            echo -n "Enter new hostname: "
            read NEW_HOSTNAME
            
            hostname $NEW_HOSTNAME
            echo "Changing transient hostname to \"$NEW_HOSTNAME\" is done."
            
            hostnamectl set-hostname $NEW_HOSTNAME
            echo "Changing static hostname to \"$NEW_HOSTNAME\" is done."

            if grep -e "^\s*127.0.1.1\s" "$HOSTS_FILE"; then 
                sed -i "s/^\s*127.0.1.1\s.*/127.0.1.1 $NEW_HOSTNAME/" "$HOSTS_FILE"
            else 
                echo "127.0.1.1 $NEW_HOSTNAME" >> "$HOSTS_FILE"
            fi
            echo "Adding new hostname to \"$HOSTS_FILE\" is done."
        fi
    done
    commit_stage_done $STAGE_NAME
fi

# 
# Update packages
# 
# APT_GET_UPDATE_LAST_TS=$( stat --format="%X" /var/cache/apt/pkgcache.bin )
# NOW_TS=$( date +%s )
# UPSINCE=$( date -d "$( uptime -s )" +%s )
# if [[ $(( NOW_TS-APT_GET_UPDATE_LAST_TS )) -gt 86400 || $(( NOW_TS-UPSINCE )) -lt 86400 ]]; then
#     echo "Updating packages."
#     apt-get -qq update
#     STATUS=$?
#     if [ $STATUS -eq 0 ];then
#         echo "Packages updated."
#     else
#         echo "Could not update packages. Continue with old packages."
#     fi
# fi
echo "Updating packages."
apt-get -qq update


#
# Install basic packages.
#
declare -a packages=(
    "acl"                   # Utilities for managing Access Control Lists for files and directories.
    "apache2-utils"         # Utility programs for the Apache HTTP Server.
    "argon2"                # High-performance password hashing function.
    "ufw"                   # Uncomplicated Firewall, a user-friendly frontend for iptables.
    "jq"                    # Lightweight and flexible command-line JSON processor. https://jqlang.org/
)

for p in "${packages[@]}"; do

    if [ $(dpkg -l | grep " $p " | wc -l) -lt 1 ]; then 
        echo "Installing $p."
        sudo apt -y install $p
    fi

done


#
# Install python packages.
#
pip install -r requirements.txt


# 
# Change root password
# 
STAGE_NAME="change_root_password"
if ! check_stage_done $STAGE_NAME; then

    if [ $(dpkg -l | grep pwgen | wc -l) -lt 1 ]; then 
        apt-get install pwgen
    fi

    NEW_ROOT_PASSWORD=$(pwgen -1BC 16 1)

    echo "Changing root password to: \"$NEW_ROOT_PASSWORD\"."

    echo "root:$NEW_ROOT_PASSWORD" | sudo chpasswd
    STATUS=$?
    if [ $STATUS -eq 0 ];then
        echo "Root password changed to: \"$NEW_ROOT_PASSWORD\"."
        commit_stage_done $STAGE_NAME
    else
        echo "Could not chpasswd."
        exit 1
    fi
fi


#
# Add ssh and sudo user and disable root login
#
NEW_USER_NAME=""
NEW_USER_HOME_DIR=""
NEW_USER_BASIC_AUTH_PASSWORD=""
NEED_ADD_USER=""
SSHD_CONFIG="/etc/ssh/sshd_config"
STAGE_NAME="add_new_ssh_user"
if ! check_stage_done $STAGE_NAME; then
    while [[ $NEED_ADD_USER != "y" ]] && [[ $NEED_ADD_USER != "n" ]]; do
        NEW_USER_NAME=""
        NEW_USER_HOME_DIR=""
        NEW_USER_PUBLIC_KEY=""
        READY_TO_GO=""

        echo -n "Create user to login instead root and disable root? [y/n] "
        read NEED_ADD_USER
        if [[ $NEED_ADD_USER == "y" ]]; then
            
            NEED_ADD_USER=""

            echo -n "User name: "
            read NEW_USER_NAME
            if [[ -z $NEW_USER_NAME ]]; then
                echo "User name can't be empty. Let's try again."
                continue
            fi

            echo -n "Basic auth password (min $MIN_PASSWORD_LENGTH symbols): "
            read NEW_USER_BASIC_AUTH_PASSWORD
            if [[ ${#NEW_USER_BASIC_AUTH_PASSWORD} -lt $MIN_PASSWORD_LENGTH ]]; then
                echo "Basic auth password must be at least $MIN_PASSWORD_LENGTH symbols long. Let's try again."
                continue
            fi

            echo -n "User public key (copy-paste it from your local ~/.ssh/id_rsa.pub file): "
            read NEW_USER_PUBLIC_KEY
            if [[ -z $NEW_USER_PUBLIC_KEY ]]; then
                echo "User public key can't be empty. Let's try again."
                continue
            fi

            NEW_USER_HOME_DIR="/home/$NEW_USER_NAME"

            echo ""
            echo ""
            echo "We are one step away from creating new user and disable root login via SSH."
            echo "User name: \"$NEW_USER_NAME\"."
            echo "User basic auth password: \"$NEW_USER_BASIC_AUTH_PASSWORD\"."
            echo "User home directory: \"$NEW_USER_HOME_DIR\"."
            echo "Public key: \"$NEW_USER_PUBLIC_KEY\"."
            echo "Add new user \"$NEW_USER_NAME\" to sudoers."
            echo "Disable SSH login as root."
            echo -n "Is information above correct and we are ready to go? [y/n] "
            read READY_TO_GO
            if [[ $READY_TO_GO == "y" ]]; then

                useradd -m -d "$NEW_USER_HOME_DIR" -s /bin/bash -G sudo $NEW_USER_NAME
                echo "$NEW_USER_NAME ALL=(ALL:ALL) NOPASSWD: ALL" > "/etc/sudoers.d/$NEW_USER_NAME" && sudo chmod 440 "/etc/sudoers.d/$NEW_USER_NAME"
                mkdir -p "$NEW_USER_HOME_DIR/.ssh"
                echo $NEW_USER_PUBLIC_KEY >> "$NEW_USER_HOME_DIR/.ssh/authorized_keys"
                chown -R $NEW_USER_NAME:$NEW_USER_NAME $NEW_USER_HOME_DIR/.ssh
                chmod 700 $NEW_USER_HOME_DIR/.ssh
                chmod 600 $NEW_USER_HOME_DIR/.ssh/authorized_keys

                if ! grep -e "^\s*PubkeyAuthentication\s\+yes" "$SSHD_CONFIG"; then 
                    echo "PubkeyAuthentication is disabled in \"$SSHD_CONFIG\". Let's fix this!"
                    if grep -e "^\s*PubkeyAuthentication\s" "$SSHD_CONFIG"; then 
                        sed -i "s/^\s*PubkeyAuthentication\s.*/PubkeyAuthentication yes/" "$SSHD_CONFIG"
                    else 
                        echo "PubkeyAuthentication yes" >> "$SSHD_CONFIG"
                    fi
                    systemctl restart ssh.service
                    echo "PubkeyAuthentication now enabled in \"$SSHD_CONFIG\" and SSHD restarted."
                fi
                
                echo "Disabling SSH login as root."
                sed -i "s/^\s*PermitRootLogin.*/PermitRootLogin no/" "$SSHD_CONFIG"
                systemctl restart ssh.service
                echo "SSH login as root disabled."

                echo "Add hashed password for \"$NEW_USER_NAME:$NEW_USER_BASIC_AUTH_PASSWORD\" to $BASIC_AUTH_CREDENTIALS_FILE."
                sudo htpasswd -cBb $BASIC_AUTH_CREDENTIALS_FILE $NEW_USER_NAME $NEW_USER_BASIC_AUTH_PASSWORD
                sudo chown root:root $BASIC_AUTH_CREDENTIALS_FILE

                commit_stage_done $STAGE_NAME
                break
            elif [[ $READY_TO_GO == "n" ]]; then
                echo "Oh! Sorry. Let's try it again."
                continue
            else
                echo "Sorry, can't understand you. Let's try again."
                continue
            fi
        elif [[ $NEED_ADD_USER == "n" ]]; then
            break
        else
            echo "Sorry, can't understand you. Let's try again."
        fi
    done
fi


# 
# Enable UFW
# 
if ufw status | grep 'Status: inactive'; then
    # Allow 22 port before enable UFW.
    STAGE_NAME="close_22_port"
    reset_stage_status $STAGE_NAME
    ufw allow ssh
    # Enable UFW.
    ufw --force enable
    STATUS=$?
    if [ $STATUS -eq 0 ];then
        echo "UFW enabled. User \`ufw status\` or \`ufw show added\` to check added rules."
    else
        echo "Unable to enable UFW."
        exit 1
    fi
else
    echo "UFW enabled. Nothing to do. Just moving forward."
fi


# 
# Change SSH port
# Sources:
#   * https://serverfault.com/questions/1159599/how-to-change-the-ssh-server-port-on-ubuntu
#   * https://raw.githubusercontent.com/fcoulloudon/ssh_custom_port/refs/heads/main/script.sh
# 
STAGE_NAME="change_ssh_port"
if ! check_stage_done $STAGE_NAME; then
    if systemctl status ssh.socket | grep 'Listen:' | grep -e ':22 ' -e ':2222 '; then
        NEW_SSH_PORT=$( random_unused_port )

        echo "Opening new SSH port $NEW_SSH_PORT in UFW."
        ufw allow $NEW_SSH_PORT/tcp
        echo "Port $NEW_SSH_PORT has opened in UFW."

        echo "Changing SSH port to $NEW_SSH_PORT"

        # Define the override directory and file
        OVERRIDE_DIR="/etc/systemd/system/ssh.socket.d"
        OVERRIDE_FILE="$OVERRIDE_DIR/override.conf"

        # Create the override directory if it doesn't exist
        if [ ! -d "$OVERRIDE_DIR" ]; then
            echo "Creating directory: $OVERRIDE_DIR"
            mkdir -p "$OVERRIDE_DIR"
        fi

        # Write the override configuration
        # Source: https://askubuntu.com/questions/1532433/custom-ssh-port-configuration-will-listen-only-on-ipv6-of-the-system
        cat <<EOF > "$OVERRIDE_FILE"
[Socket]
ListenStream=
ListenStream=0.0.0.0:$NEW_SSH_PORT
EOF

        echo "SSH configuration written to $OVERRIDE_FILE"

        # Modify the SSH server configuration file
        SSHD_CONFIG="/etc/ssh/sshd_config"
        if grep -q "^Port " "$SSHD_CONFIG"; then
            sed -i "s/^Port .*/Port $NEW_SSH_PORT/" "$SSHD_CONFIG"
        else
            echo "Port $NEW_SSH_PORT" >> "$SSHD_CONFIG"
        fi

        echo "SSH server configuration updated in $SSHD_CONFIG"

        # Reload systemd to apply changes
        systemctl daemon-reload
        # Restart the SSH socket
        systemctl restart ssh.socket

        # Restart the SSH service
        systemctl restart ssh.service

        echo "SSH port has been changed to $NEW_SSH_PORT. Verify by running: systemctl status ssh.socket and systemctl status ssh.service"
        ss -lntu
    fi
    commit_stage_done $STAGE_NAME
fi


#
# Close 22 port in UFW.
#
STAGE_NAME="close_22_port"
echo "Now old SSH port will be denied in UFW. Reconnect to new port $NEW_SSH_PORT."
ufw deny ssh
commit_stage_done $STAGE_NAME


# 
# Print final configuration
# 
echo "#######################"
echo "# Final configuration."
echo "#######################"

if [[ $NEED_SETUP_HOSTNAME == "y" ]] && [[ -n NEW_HOSTNAME ]]; then
    echo "New hostname: $NEW_HOSTNAME"
fi

if [[ -n $NEW_ROOT_PASSWORD ]]; then
    echo "New root password: $NEW_ROOT_PASSWORD"
fi

if [[ -n $NEW_SSH_PORT ]]; then
    echo "New SSH port: $NEW_SSH_PORT"
fi

if [[ -n $NEW_USER_NAME ]]; then
    echo "New user: $NEW_USER_NAME"
    echo "New user basic auth password: $NEW_USER_BASIC_AUTH_PASSWORD"
    echo "Login to SSH as \"root\" disabled."
    echo "User \"$NEW_USER_NAME\" added to sudo group."
    echo "User \"$NEW_USER_NAME\" has no password, use SSH key authentication. Add host configuration to your local \"~/.ssh/config\" file, see more in https://serverfault.com/questions/262626/how-to-configure-ssh-client-to-use-private-keys-automatically"
fi

